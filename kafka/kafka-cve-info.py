# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: MIT-0

import argparse
import random
from datetime import datetime, timedelta
import socket
from confluent_kafka import Producer
from fastavro import parse_schema, schemaless_writer
import io
import time
from aws_msk_iam_sasl_signer import MSKAuthTokenProvider

def oauth_cb(oauth_config):
    auth_token, expiry_ms = MSKAuthTokenProvider.generate_auth_token(oauth_config.get('region', 'us-east-1'))
    # Note that this library expects oauth_cb to return expiry time in seconds since epoch, while the token generator returns expiry in ms
    return auth_token, expiry_ms/1000


# Define the Avro schema
cveinfo_schema = {
    "namespace": "security.cve",
    "type": "record",
    "name": "CVEInfo",
    "fields": [
        {"name": "cve_id", "type": "string"},
        {"name": "description", "type": "string"},
        {"name": "severity", "type": "string"},        
        {"name": "cvss_score", "type": "double"},        
        {"name": "published_date", "type": {"type": "long","logicalType": "timestamp-millis"}},
        {"name": "last_modified_date", "type": {"type": "long","logicalType": "timestamp-millis"}},        
        {"name": "affected_software_name", "type":"string"},
        {"name": "affected_version_range", "type":"string"},
        {"name": "remediation_info", "type":"string"}
    ]
}
parsed_schema = parse_schema(cveinfo_schema)

# Value pools
software_names = ['OpenSSL', 'Nginx', 'Apache HTTPD', 'MySQL', 'PostgreSQL', 'Docker', 'Kubernetes']
severities = ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']
desc_samples = [
    'Buffer overflow in ...',
    'SQL injection in ...',
    'Race condition in ...',
    'Privilege escalation in ...',
    'Cross-site scripting in ...'
]

def generate_cveinfo():
    cve_num = random.randint(10000, 99999)
    year = random.randint(2018, 2024)
    cve_id = f"CVE-{year}-{cve_num}"
    published_date = (datetime.now() - timedelta(days=random.randint(0, 1200)))
    last_modified_date = published_date + timedelta(days=random.randint(0, 30))
    #cvss_score = round(random.uniform(3.0, 10.0), 1)
    severity = random.choice(severities)
    # Generate CVSS score based on severity
    if severity == 'CRITICAL':
        cvss_score = round(random.uniform(9.0, 10.0), 1)
    elif severity == 'HIGH':
        cvss_score = round(random.uniform(7.0, 8.9), 1)
    else: 
        cvss_score = round(random.uniform(3.0, 6.9), 1)

    affected_software = random.choice(software_names)
    description = random.choice(desc_samples)
    references = f"https://nvd.nist.gov/vuln/detail/{cve_id}"
    affected_version_range =  f"<= {random.randint(1,20)}.{random.randint(0,9)}"
    return {
        "cve_id": cve_id,
        "description": description,
        "severity": severity,        
        "cvss_score": cvss_score,
        "published_date": published_date,        
        "last_modified_date": last_modified_date,        
        "affected_software_name": affected_software,
        "affected_version_range": affected_version_range,
        "remediation_info": references        
    }

def delivery_report(err, msg):
    if err is not None:
        print('Delivery failed:', err)
    else:
        print(f"Message delivered to {msg.topic()} partition {msg.partition()} offset {msg.offset()}")

# --------------- Argument Parser and Main Logic -----------
def parse_arguments():
    parser = argparse.ArgumentParser(
        description='Generate simulated events for network and endpoint schemas')
    parser.add_argument('--topic-name', dest='topic', action='store',
                        required=True, help='Kafka topic name')
    parser.add_argument("-c", "--count", type=int, default=10,
                        help="Number of messages to send")
    parser.add_argument('--broker', dest='bserver', action='store',
                        required=True, help='Kafka broker address')
    parser.add_argument('--region', dest='region', action='store',
                        default='us-east-1', help='AWS region (default: us-east-1)')    
    args = parser.parse_args()
    # set global region variable with the region value passed in the argument
    region_g = args.region    
    return args

def main():
    args = parse_arguments()
    producer_config = {
        'bootstrap.servers': args.bserver,
        'batch.size': 262144, # num of bytes
        'linger.ms': 10, # after 10 milisec send the package
        'acks': 1,
        #'client.id': args.clientid,
        'client.id': socket.gethostname(),                
        'compression.codec': 'snappy',
        'security.protocol': 'SASL_SSL',
        'sasl.mechanisms': 'OAUTHBEARER',
        'oauth_cb': lambda config: oauth_cb({'region': args.region}),
    }
    
    producer = Producer(producer_config)
    topic = args.topic
    num_messages = args.count
    batch_id = 0
    current_time = datetime.utcnow()
    
    print('Start of data gen - ', str(datetime.now()))
    for _ in range(num_messages):
        record = generate_cveinfo()
        buf = io.BytesIO()
        schemaless_writer(buf, parsed_schema, record)
        value = buf.getvalue()
        producer.produce(
            topic,
            value=value,
            callback=delivery_report
        )
        producer.poll(0)
        #time.sleep(0.1)
    producer.flush()

if __name__ == "__main__":
    main()
